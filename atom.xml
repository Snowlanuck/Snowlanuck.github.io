<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://snowlanuck.github.io/</id>
    <title>Snowlanuck Blog</title>
    <updated>2020-12-07T07:23:36.943Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://snowlanuck.github.io/"/>
    <link rel="self" href="https://snowlanuck.github.io/atom.xml"/>
    <subtitle>Aw.16982</subtitle>
    <logo>https://snowlanuck.github.io/images/avatar.png</logo>
    <icon>https://snowlanuck.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Snowlanuck Blog</rights>
    <entry>
        <title type="html"><![CDATA[数据结构与算法入门指南 - 二分]]></title>
        <id>https://snowlanuck.github.io/post/shu-ju-jie-gou-yu-suan-fa-ru-men-zhi-nan-er-fen/</id>
        <link href="https://snowlanuck.github.io/post/shu-ju-jie-gou-yu-suan-fa-ru-men-zhi-nan-er-fen/">
        </link>
        <updated>2020-12-07T07:22:29.000Z</updated>
        <content type="html"><![CDATA[<p>二分指在有序的数组中快速查找某个值，这里不得不提到我们生活中经常遇到的一个小游戏：猜数字，给定一个范围，让你猜某个数字，每次猜错就告诉你是大了还是小了。</p>
<p>按照二分的思想，猜数字时我们会直接猜中间的数字，比如给出范围1~1000，我们会直接猜500，再看是大了还是小了再折半缩小需要猜的范围，这样就可以用最少的次数猜到数字。</p>
<p>例如我们要在1~1000的范围内猜799，注意：默认下取整</p>
<pre><code>猜(1 + 1000) / 2 = 500：小了
猜(500 + 1000) / 2 = 750：小了
猜(750 + 1000) / 2 = 875：大了
猜(750 + 875) / 2 = 812：大了
猜(750 + 812) / 2 = 781：小了
猜(781 + 812) / 2 = 796：小了
猜(796 + 812) / 2 = 804：大了
猜(796 + 804) / 2 = 800：大了
猜(796 + 800) / 2 = 798：小了
猜(798 + 800) / 2 = 799：完毕
</code></pre>
<p>虽然例子比较长，但应该能换来清晰直观的理解。</p>
<p>可以发现每次都是<code>(左端点 + 右端点) / 2</code>，再看是大了还是小了去限制左端点和右端点，如果是大了就缩小右端点的值，如果是小了就扩大左端点的值。</p>
<h2 id="lower_bound与upper_bound"><code>lower_bound</code>与<code>upper_bound</code></h2>
<p>C++自带的<code>lower_bound</code>与<code>upper_bound</code>这两个函数，可以帮我们用二分在数组中快速查找某个值。</p>
<p>注意：数组必须是有序的（这两个函数默认数组是从小到大排序的），如果要在无序数组中查找则需要先排序，可以看看 <a href="1.%E6%8E%92%E5%BA%8F.md">1.排序.md</a></p>
<p><code>lower_bound(begin, end, x)</code>返回在(begin, end-1)区间中第一个大于等于x的值的地址。</p>
<p><code>upper_bound(begin, end, x)</code>返回在(begin, end-1)区间中第一个大于x的值的地址。</p>
<p>可以看到<code>lower_bound</code>与<code>upper_bound</code>的区别就是一个可以等于x，可以只能大于x。</p>
<p>如果x不在数组中，这两个函数会返回什么呢？</p>
<ul>
<li>如果x小于数组中的最小值，会返回begin，因为一直往左找，找到边界就停下来了。</li>
<li>如果x大于数组中的最大值，会返回end，因为一直往右找，找到边界就停下来了。</li>
<li>如果x的范围在(begin, end)中，<code>lower_bound</code>会返回与<code>upper_bound</code>一样的结果，因为找不到相等的值了。</li>
</ul>
<p>那么我们来看看实际用法吧</p>
<pre><code class="language-cpp">int A[10] = { 1,3,6,9,12,14,18,22,34,54 };
int index = lower_bound(A, A + 10, 9) - A;//获取符合值的下标 用返回元素的地址减去首地址就是下标了
int value = A[index]; //获取值 也可以一步到位 value = *lower_bound(A, A + 10, 9)
</code></pre>
<p>如何判断x是否在数组内呢？</p>
<pre><code class="language-cpp">int A[10] = { 1,3,6,9,12,14,18,22,34,54 };
int index = lower_bound(A, A + 10, 11) - A; //获取符合值的下标
//判断下标是否出界和值是否相同即可
if (index &lt; 10 &amp;&amp; A[index] == 11) puts(&quot;11在A中&quot;);
else puts(&quot;11不在A中&quot;);
</code></pre>
<p>如果数组是从大到小排序的呢？就不能用<code>lower_bound</code>与<code>upper_bound</code>了嘛？当然不是，这两个方法还有第四个参数，传入方法或匿名函数，可以自定义排序。</p>
<pre><code class="language-cpp">int A[10] = { 99,71,66,62,54,52,38,35,26,1 };
int value = *lower_bound(A, A + 10, 66, greater&lt;int&gt;()); //value = 66
</code></pre>
<h2 id="整数二分模板">整数二分模板</h2>
<p>有些可以用二分法来快速查找值的情况，但无法直接用<code>lower_bound</code>与<code>upper_bound</code>怎么办呢？就例如结构体数组中要查找某个元素的属性符合该值，那么我们就只能手写二分了。</p>
<p>由于边界问题会导致死循环，所以某些情况下需要<code>+1</code>或<code>-1</code>。</p>
<pre><code class="language-cpp">bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用
int bsearch(int l, int r)
{
    while (l &lt; r)
    {
        int mid = (l + r) / 2;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用
int bsearch(int l, int r)
{
    while (l &lt; r)
    {
        int mid = (l + r + 1) / 2;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
</code></pre>
<p>看个小栗子🌰，其实就是把<code>lower_bound</code>实现了，动动手，看能不能写出<code>upper_bound</code>的效果（查找大于x的第一个值）？</p>
<pre><code class="language-cpp">int A[10] = { 5,6,13,16,25,31,35,46,58,77 };
int x = 35; // 要查找的值

int l = 0, r = 9;
while (l &lt; r)
{
    int mid = (l + r) / 2;
    if (A[mid] &gt;= x) r = mid;
    else l = mid + 1;
}
cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; A[l]; // 6 35
</code></pre>
<h2 id="浮点数二分模板">浮点数二分模板</h2>
<p>这里需要提一下的就是，判断两个浮点数是否相等的方法一般是不会用<code>==</code>来判断的，会有误差，那么我们只需要判断两个浮点数差的绝对值非常小就行了。1e-6 = 0.000001</p>
<pre><code class="language-cpp">bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l &gt; eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
</code></pre>
<p>再来看个栗子🌰，数的三次方根。</p>
<pre><code class="language-cpp">double x = 99; //要求99的三次方根
double l = -10e5, r = 10e5; //可以取大一点范围，二分的效率很高的

while (r - l &gt; 10e-8) //如果两个浮点数不相等
{
    double mid = (l + r) / 2;
    if (mid * mid * mid &gt; x) r = mid; // mid^3 &gt; x
    else l = mid;
}

cout &lt;&lt; l; // 4.62606
</code></pre>
<h2 id="题目">题目</h2>
<p>待增加，还是放上洛谷的官方题单。</p>
<p><a href="https://www.luogu.com.cn/training/111">【算法1-6】二分查找与二分答案 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法入门指南 - 关于]]></title>
        <id>https://snowlanuck.github.io/post/shu-ju-jie-gou-yu-suan-fa-ru-men-zhi-nan-guan-yu/</id>
        <link href="https://snowlanuck.github.io/post/shu-ju-jie-gou-yu-suan-fa-ru-men-zhi-nan-guan-yu/">
        </link>
        <updated>2020-12-07T07:04:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="关于">关于</h1>
<p>博客主要记录关于算法方面的知识（可能偏竞赛方面），代码均使用C++编写，不包含基础的语法介绍。</p>
<p>遵从宁繁勿简、深入浅出的原则，每篇文章都会配上例题，尽量给出代码，方便学习。</p>
<p>初学者入门数据结构与算法时，面对那么多的平台和题库，可能无从下手，找不到一个系统学习的方法，也许这系列的文章能帮你系统的学到知识，有效的提高思维与代码水平😉。</p>
<p><a href="https://oi.docs.snowlanuck.ink/">或许更好的阅读体验</a></p>
<p>推荐的OJ（在线评测系统）</p>
<ul>
<li><a href="https://www.luogu.com.cn/">洛谷</a> 比较偏重竞赛，有官方月赛和用户举办的比赛，题目较多。</li>
<li><a href="https://leetcode-cn.com/">LeetCode</a> 找工作用，难度偏低，有周赛。</li>
<li><a href="https://ac.nowcoder.com/acm/home">牛客竞赛</a> 工作&amp;竞赛，举办的比赛较多。</li>
</ul>
<h1 id="目录陆续更新">目录（陆续更新）</h1>
<h2 id="基础算法">基础算法</h2>
<ul>
<li>
<h3 id="排序">排序</h3>
</li>
<li>
<h3 id="二分">二分</h3>
</li>
<li>
<h3 id="高精度">高精度</h3>
</li>
<li>
<h3 id="前缀和与差分">前缀和与差分</h3>
</li>
<li>
<h3 id="双指针">双指针</h3>
</li>
<li>
<h3 id="位运算">位运算</h3>
</li>
<li>
<h3 id="离散化">离散化</h3>
</li>
</ul>
<h2 id="数据结构">数据结构</h2>
<ul>
<li>
<h3 id="链表">链表</h3>
</li>
<li>
<h3 id="栈">栈</h3>
</li>
<li>
<h3 id="队列">队列</h3>
</li>
<li>
<h3 id="堆">堆</h3>
</li>
<li>
<h3 id="字符串">字符串</h3>
</li>
<li>
<h3 id="并查集">并查集</h3>
</li>
<li>
<h3 id="哈希表">哈希表</h3>
</li>
<li>
<h3 id="线段树">线段树</h3>
</li>
<li>
<h3 id="平衡树">平衡树</h3>
</li>
</ul>
<h2 id="搜索">搜索</h2>
<ul>
<li>
<h3 id="广度优先搜索bfs">广度优先搜索(BFS)</h3>
<ul>
<li>
<h4 id="flood-fill">Flood Fill</h4>
</li>
<li>
<h4 id="最短路">最短路</h4>
</li>
<li>
<h4 id="多源bfs">多源BFS</h4>
</li>
<li>
<h4 id="双向广搜">双向广搜</h4>
</li>
<li>
<h4 id="a">A*</h4>
</li>
</ul>
</li>
<li>
<h3 id="深度优先搜索dfs">深度优先搜索（DFS）</h3>
<ul>
<li>
<h4 id="全排列">全排列</h4>
</li>
<li>
<h4 id="连通性模型">连通性模型</h4>
</li>
<li>
<h4 id="剪枝与优化">剪枝与优化</h4>
</li>
<li>
<h4 id="迭代加深">迭代加深</h4>
</li>
<li>
<h4 id="ida">IDA*</h4>
</li>
</ul>
</li>
</ul>
<h2 id="图论">图论</h2>
<ul>
<li>
<h3 id="最短路-2">最短路</h3>
<ul>
<li>
<h4 id="拓扑排序">拓扑排序</h4>
</li>
<li>
<h4 id="dijkstra">Dijkstra</h4>
</li>
<li>
<h4 id="bellman-ford">bellman-ford</h4>
</li>
<li>
<h4 id="spfa">spfa</h4>
</li>
<li>
<h4 id="floyd">Floyd</h4>
</li>
<li>
<h4 id="分层图">分层图</h4>
</li>
</ul>
</li>
<li>
<h3 id="最小生成树">最小生成树</h3>
<ul>
<li>
<h4 id="prim">Prim</h4>
</li>
<li>
<h4 id="kruskal">Kruskal</h4>
</li>
</ul>
</li>
<li>
<h3 id="二分图">二分图</h3>
</li>
</ul>
<h2 id="动态规划">动态规划</h2>
<ul>
<li>
<h3 id="背包">背包</h3>
</li>
<li>
<h3 id="最长上升子序列">最长上升子序列</h3>
</li>
<li>
<h3 id="状态压缩dp">状态压缩DP</h3>
</li>
<li>
<h3 id="区间dp">区间DP</h3>
</li>
<li>
<h3 id="树形dp">树形DP</h3>
</li>
<li>
<h3 id="数位dp">数位DP</h3>
</li>
<li>
<h3 id="单调队列优化dp">单调队列优化DP</h3>
</li>
<li>
<h3 id="斜率dp">斜率DP</h3>
</li>
</ul>
<h2 id="数学">数学</h2>
<ul>
<li>
<h3 id="筛质数">筛质数</h3>
</li>
<li>
<h3 id="分解质因数">分解质因数</h3>
</li>
<li>
<h3 id="快速幂">快速幂</h3>
</li>
<li>
<h3 id="欧拉函数">欧拉函数</h3>
</li>
<li>
<h3 id="组合计数">组合计数</h3>
</li>
<li>
<h3 id="高斯消元">高斯消元</h3>
</li>
<li>
<h3 id="容斥原理">容斥原理</h3>
</li>
<li>
<h3 id="概率与数学期望">概率与数学期望</h3>
</li>
<li>
<h3 id="博弈论">博弈论</h3>
</li>
</ul>
<h1 id="万能头-与-visual-studio">万能头 与 Visual Studio</h1>
<p>如果你使用Visual Studio，并且没有导入万能头，可以继续往下看</p>
<p>万能头文件涵盖了做题中需要的大部分头文件（在做题中我就没遇到需要额外导入其他头文件的题😂）。其包含的头文件较多，所以编译的时间也会比较多，但不会影响运行时间。</p>
<p>万能头文件使用:  <code>#include &lt;bits/stdc++.h&gt;</code></p>
<p>但在Visual Studio中无法直接引用万能头，需要自己手动添加。</p>
<p>stdc++.h源码：</p>
<pre><code class="language-cpp">// C++ includes used for precompiling -*- C++ -*-

// Copyright (C) 2003-2014 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// &lt;http://www.gnu.org/licenses/&gt;.

/** @file stdc++.h
 *  This is an implementation file for a precompiled header.
 */

// 17.4.1.2 Headers

#define _CRT_SECURE_NO_WARNINGS

// C
#ifndef _GLIBCXX_NO_ASSERT
#include &lt;cassert&gt;
#endif
#include &lt;cctype&gt;
#include &lt;cerrno&gt;
#include &lt;cfloat&gt;
#include &lt;ciso646&gt;
#include &lt;climits&gt;
#include &lt;clocale&gt;
#include &lt;cmath&gt;
#include &lt;csetjmp&gt;
#include &lt;csignal&gt;
#include &lt;cstdarg&gt;
#include &lt;cstddef&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;

#if __cplusplus &gt;= 201103L
#include &lt;ccomplex&gt;
#include &lt;cfenv&gt;
#include &lt;cinttypes&gt;
#include &lt;cstdalign&gt;
#include &lt;cstdbool&gt;
#include &lt;cstdint&gt;
#include &lt;ctgmath&gt;
#include &lt;cwchar&gt;
#include &lt;cwctype&gt;
#endif

// C++
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;complex&gt;
#include &lt;deque&gt;
#include &lt;exception&gt;
#include &lt;fstream&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;ios&gt;
#include &lt;iosfwd&gt;
#include &lt;iostream&gt;
#include &lt;istream&gt;
#include &lt;iterator&gt;
#include &lt;limits&gt;
#include &lt;list&gt;
#include &lt;locale&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;new&gt;
#include &lt;numeric&gt;
#include &lt;ostream&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;stdexcept&gt;
#include &lt;streambuf&gt;
#include &lt;string&gt;
#include &lt;typeinfo&gt;
#include &lt;utility&gt;
#include &lt;valarray&gt;
#include &lt;vector&gt;

#if __cplusplus &gt;= 201103L
#include &lt;array&gt;
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;condition_variable&gt;
#include &lt;forward_list&gt;
#include &lt;future&gt;
#include &lt;initializer_list&gt;
#include &lt;mutex&gt;
#include &lt;random&gt;
#include &lt;ratio&gt;
#include &lt;regex&gt;
#include &lt;scoped_allocator&gt;
#include &lt;system_error&gt;
#include &lt;thread&gt;
#include &lt;tuple&gt;
#include &lt;typeindex&gt;
#include &lt;type_traits&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#endif
</code></pre>
<p>在Visual Studio中使用scanf之类的C语言内置函数会报错，因为Visual Studio认为这些函数不安全，应使用scanf_s之类的函数，但在代码中加入 <code>#define _CRT_SECURE_NO_WARNINGS</code>即可屏蔽这类的安全提示，毕竟我们是写算法的嘛。我已经把屏蔽安全提示的语句添加至上面的代码中了，直接复制使用即可。</p>
<p>快速添加至Visual Studio的方法：</p>
<ol>
<li>
<p>先随便引用一个系统头文件，对其右键选择转到文档。</p>
<figure data-type="image" tabindex="1"><img src="https://snowlanuck.github.io//post-images/1607324688455.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>对新打开的文件（注意在右上角）右键，选择打开所在文件夹。</p>
<figure data-type="image" tabindex="2"><img src="https://snowlanuck.github.io//post-images/1607324697710.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>新建一个bits文件夹，把stdc++.h文件拖入</p>
</li>
<li>
<p>直接在Visual Studio中使用<code>#include &lt;bits/stdc++.h&gt;</code>即可</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法入门指南 - 排序]]></title>
        <id>https://snowlanuck.github.io/post/shu-ju-jie-gou-yu-suan-fa-ru-men-zhi-nan-pai-xu/</id>
        <link href="https://snowlanuck.github.io/post/shu-ju-jie-gou-yu-suan-fa-ru-men-zhi-nan-pai-xu/">
        </link>
        <updated>2020-12-07T06:55:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>了解各个排序的算法原理比较适合找工作面试的时候用，在刷题竞赛的时候直接使用sort函数即可</p>
</blockquote>
<h2 id="sort函数">sort函数</h2>
<p>sort作为C++自带的函数，使用频率比较高，一般遇到需要排序的数组用就行了，能解决大部分需要排序的问题。下面演示一下各种用法。</p>
<h3 id="基础用法">基础用法</h3>
<p>最基础的用法，对数组直接排序（默认从小到大排序）。</p>
<pre><code class="language-cpp">int A[10] = { 5,4,8,7,6,4,1,6,5,1 };
sort(A, A + 10); // A = { 1,1,4,4,5,5,6,6,7,8 }
</code></pre>
<p>sort函数的前两个参数为首地址与尾地址，表示需要排序一段数组。在上例中，A有10个元素，而使用A时会返回A的首地址，A + 10表示在首地址上向后偏移10个位置后的地址，用(A，A + 10)可以表示A[0 ~ 9]。</p>
<p>如果只想对前五位排序，也可以这样写<code>sort(A, A + 5)</code>。</p>
<p>对于STL中的vector也是如此，使用对象中的<code>begin()</code>与<code>end()</code>获取首地址与尾地址。</p>
<pre><code class="language-cpp">vector&lt;int&gt; A = { 5,4,6,8,7,4,1,6,9 };
sort(A.begin(), A.end()); // A = { 1,4,4,5,6,6,7,8,9 }
</code></pre>
<p>那么对于自定义的结构体呢？看下面。</p>
<h3 id="自定义排序用法">自定义排序用法</h3>
<p>sort函数还有第三个可选参数，就是自定义排序的方法，传入方法名或者匿名函数即可。传入的方法的参数必须是两个同类型的且返回值为bool类型。</p>
<p>如果不使用第三个参数，sort函数会默认调用对象的<code>&lt;</code>方法来比较两个对象的大小关系，使用结构体时需要重写一下<code>operator&lt;</code>。</p>
<ul>
<li>
<p>使用匿名函数</p>
<pre><code class="language-cpp">int A[10] = { 5,1,7,9,5,4,8,3,1,0 };
sort(A, A + 10, [](int a, int b) { return a &gt; b; }); //从大到小排序
//A = { 9,8,7,5,5,4,3,1,1,0 }
</code></pre>
</li>
<li>
<p>使用方法</p>
<pre><code class="language-cpp">//从大到小排序
bool cmp(int a, int b) { return a &gt; b; }

int main()
{
	int A[10] = { 5,1,7,9,5,4,8,3,1,0 };
	sort(A, A + 10, cmp); //A = { 9,8,7,5,5,4,3,1,1,0 }
	return 0;
}
</code></pre>
</li>
<li>
<p>结构体重载<code>operator&lt;</code></p>
<pre><code class="language-cpp">struct Node 
{
	int a, b;
	//按a对Node从小到大排序（与传入的Node比较）
	bool operator&lt;(Node u) const
	{
		return a &lt; u.a;
	}
};

int main()
{
	Node A[3] =  { {1, 6}, {8, 0}, {4, 5} };
	sort(A, A + 3); // A =  { {1, 6}, {4, 5}, {8, 0} };

	return 0;
}
</code></pre>
<p>当然，也可以选择不重载<code>operator&lt;</code>，直接传匿名函数或者方法。</p>
</li>
</ul>
<h3 id="lesst与greatert"><code>less&lt;T&gt;()</code>与<code>greater&lt;T&gt;()</code></h3>
<p>如果只是想让元素 从小到大 或者 从大到小 排序，那么大可不必自己手写一个方法实现，直接使用系统内置的<code>less&lt;T&gt;()</code>与<code>greater&lt;T&gt;()</code>即可，T为元素类型。</p>
<pre><code class="language-cpp">sort(A, A + 10, less&lt;int&gt;()); //从小到大排序
sort(A, A + 10, greater&lt;int&gt;()); //从大到小排序
</code></pre>
<ul>
<li><code>less&lt;T&gt;()</code>需要类重载<code>operator&lt;()</code></li>
<li><code>greater&lt;T&gt;()</code>需要类重载<code>operator&gt;()</code></li>
</ul>
<hr>
<blockquote>
<p>快速排序与归并排序都用了递归实现，如果你对递归并不是很熟练，可以大概了解后暂时跳过，以后再回来看看。</p>
</blockquote>
<h2 id="quicksort-快速排序">QuickSort 快速排序</h2>
<p>快速排序先会随机找一个基准点，把小于基准点的数放到左边，把大于基准点的数放到右边，再将区间划分为两半递归执行，一直如此划分下去，就达到了排序的目的。</p>
<p>具体的排序方法：确定基准点后，双指针从数组两端向中间移动，左边指针先找到大于基准点的，然后右指针移动到小于基准点的，交换两个指针的数值即可。</p>
<p>引用一下《啊哈！算法》这本书中的快速排序流程图，将双指针看成两个哨兵。（以左端点6为基准点，右指针先出发）</p>
<figure data-type="image" tabindex="1"><img src="https://snowlanuck.github.io//post-images/1607325632798.jpg" alt="" loading="lazy"></figure>
<center>左右指针找到符合条件的值，交换！</center>
<figure data-type="image" tabindex="2"><img src="https://snowlanuck.github.io//post-images/1607325639528.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://snowlanuck.github.io//post-images/1607325645170.jpg" alt="" loading="lazy"></figure>
<center>交换完之后继续查找，找到后继续交换，直到两个哨兵（双指针）相遇为止。</center>
<figure data-type="image" tabindex="4"><img src="https://snowlanuck.github.io//post-images/1607325656855.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://snowlanuck.github.io//post-images/1607325671578.jpg" alt="" loading="lazy"></figure>
<center>两个哨兵相遇后，我们要把基准值放到相遇的位置，也就是中间，毕竟左边都是比基准值小的，右边都是比基准值大的数嘛。</center>
<figure data-type="image" tabindex="6"><img src="https://snowlanuck.github.io//post-images/1607325679949.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://snowlanuck.github.io//post-images/1607325688374.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://snowlanuck.github.io//post-images/1607325694294.jpg" alt="" loading="lazy"></figure>
<center>到此第一轮排序完毕，但我们发现整个数组其实并没有完全排好序，接下来需要将其不断分成左右两个区间重复上述过程最后就能将整个数组排序完毕了。</center>
<figure data-type="image" tabindex="9"><img src="https://snowlanuck.github.io//post-images/1607325703153.jpg" alt="" loading="lazy"></figure>
<p>下面我们来写写代码吧，上模板题！（代码实现与上述过程有所差异，不过原理大致相同）</p>
<p><a href="https://www.luogu.com.cn/problem/P1177">P1177 【模板】快速排序</a> （注意：该题如果随机选取的数为最左边的数，即x = A[L]，则会超时）</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 100000 + 10;
int n, A[maxn];

void quick_sort(int l, int r)
{
    if (l &gt;= r) return; //不能再划分区间了，终止
    
    //x为随机选取的值，i为起点，j为终点。
    int x = A[(l + r) / 2], i = l - 1, j = r + 1;
    while (i &lt; j)
    {
        while (A[++i] &lt; x); //找出左边大于x的值 (当A[j] &gt; x 时循环停止 即目前A[j] &gt; x
        while (A[--j] &gt; x); //同理找出右边小于x的值
        if (i &lt; j) swap(A[i], A[j]); //如果符合要求则交换
    }
    quick_sort(l, j); //继续划分左边
    quick_sort(j + 1, r); //划分右边
}

int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; A[i];

    quick_sort(0, n - 1);

    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; A[i] &lt;&lt; ' ';

    return 0;
}
</code></pre>
<h2 id="mergesort-归并排序">MergeSort 归并排序</h2>
<p>归并排序与快速排序最大的不同就是 快速排序是先排序再划分，而归并排序是先划分再排序，其中间过程可以理解为合并两个有序数组（这一步需要开额外空间实现）。</p>
<p>合并两个有序数组的方法：比较两个数组开头的数，谁小就选谁，最后如果有数组不为空，则一次性全部选取即可。具体题目：<a href="https://leetcode-cn.com/problems/merge-sorted-array/"><strong>88. 合并两个有序数组</strong></a></p>
<p>我们没有对数组排过序，又怎么会得到有序数组让我们合并呢，其实划分最终会划分到每个元素上，对于单个元素而言不需要在意顺序了。</p>
<p>依旧可以使用上面的题目来练手归并排序<a href="https://www.luogu.com.cn/problem/P1177"> P1177 【模板】快速排序</a></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 100000 + 10;
int n, A[maxn], B[maxn];

void merge_sort(int l, int r)
{
    if (l &gt;= r) return;

    int mid = (l + r) / 2; //找出中点
    merge_sort(l, mid); merge_sort(mid + 1, r); //划分两边
    //合并两个有序数组（当划分到只有一个元素的时候也是有序的）
    int k = l, i = l, j = mid + 1;
    while (i &lt;= mid &amp;&amp; j &lt;= r)
        if (A[i] &lt;= A[j]) B[k++] = A[i++];
        else B[k++] = A[j++];
    //两个数组合并完毕，只要数组中有元素就放进去（只要一组有，可以保证另一组为空，所以不用做判断）
    while (i &lt;= mid) B[k++] = A[i++];
    while (j &lt;= r) B[k++] = A[j++];

    for (i = l; i &lt;= r; i++) A[i] = B[i]; //将排序好的数组覆盖放入原数组中
}

int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; A[i];

    merge_sort(0, n - 1);

    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; A[i] &lt;&lt; ' ';

    return 0;
}
</code></pre>
<h2 id="关于其他排序算法">关于其他排序算法</h2>
<p>大部分算法的时间复杂度与空间复杂度都没有快速排序与归并排序好，所以这里就不一一细说了，列举一下其他常见的排序算法，有兴趣可以自己了解了解。</p>
<ul>
<li>冒泡排序</li>
<li>插入排序</li>
<li>希尔排序</li>
<li>选择排序</li>
<li>桶排序</li>
<li>计数排序</li>
<li>基数排序</li>
<li>...</li>
</ul>
<h2 id="题目">题目</h2>
<p>题目列表待增加，洛谷的官方题单是个不错的选择。</p>
<p><a href="https://www.luogu.com.cn/training/107">【算法1-2】排序 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[技术生涯]]></title>
        <id>https://snowlanuck.github.io/post/ji-zhu-sheng-ya/</id>
        <link href="https://snowlanuck.github.io/post/ji-zhu-sheng-ya/">
        </link>
        <updated>2020-05-04T09:18:13.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/user/87259">洛谷</a> <a href="https://www.acwing.com/user/myspace/index/32737/">AcWing</a> <a href="https://leetcode-cn.com/u/snowlanuck/">LeetCode</a></p>
<h1 id="算法数据结构">算法&amp;数据结构</h1>
<p><a href="https://oi.docs.snowlanuck.ink/">学习笔记</a></p>
<p><s>紫书(算法竞赛入门经典  第2版)</s> 粗略的一刷, 40%+的题 (动规+数论+12章 略过) 2020/04/06</p>
<p><s>AcWing 算法基础课</s> （一刷 2020/05/14 二刷复习 2020/05/16</p>
<p>AcWing 算法提高课</p>
<p>洛谷官方题单</p>
<p>AcWing 《算法竞赛进阶指南》打卡活动 (刷题)</p>
<p>算法竞赛入门经典训练指南</p>
<p>紫书二刷</p>
<p>[骗分导论]</p>
<p>[信息学奥赛之数学一本通]</p>
<p>算法导论</p>
<h1 id="程序设计">程序设计</h1>
]]></content>
    </entry>
</feed>